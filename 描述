
--- 新数据处理结果 ---

--- 新数据处理结果 ---
标题:
随机一题

题目描述:
【软件认证】编程语言管理系统 请实现一个对代码仓中各编程语言的代码量进行统计的系统，支持以下功能：   CodeStatsSystem(products[]) -- 初始化产品及其代码仓关系，所有代码仓的代码量初始为 0：  products[i] = [productId, repoIds[]] 表示一个产品及其代码仓列表. 产品、代码仓均是全局唯一的，一个代码仓仅会归属某一个产品，一个代码仓内可能有多种语言。    changeCodelines(int repoId, int languageId, int codeline) -- 代码仓 repoId 中某种语言 languageId 的代码行变化量为 codeline（正值表示增加，负值表示减少）。最后返回此代码仓中该语言的代码总行数。  用例保证代码仓已存在，一个代码仓中某语言的代码行不会减少为负值。    statLanguage(int productId) -- 统计产品 productId 所用到的各语言的代码总行数，并按要求返回语言id列表。  productId 为 0 表示所有产品，非 0 表示指定的产品（用例保证产品已存在）。 返回要求：只返回代码量大于 0 的语言；优先按语言的代码量降序；若代码量相同，则再按语言id升序。

输入:
每行表示一个函数调用，初始化函数仅首行调用一次，累计函数调用不超过1000次。  1 <= products.length <= 100, 0 < products[i].productId <= 100，1 <= repoIds.length <= 10 0 <=  repoIds[j]、repoId < 1000 （repoId ∈\in∈ repoIds）；-100000 <= codeline <= 100000 languageId 取值范围 0~6，分别表示 ""c"", ""c++"", ""go"", ""java"", ""javascript"", ""python"", ""rust"" 0 <= productId <= 100

输出:
答题时按照函数/方法原型中的要求（含返回值）进行实现，输出由框架完成（其中首行固定输出 null）

样例:
1复制输入：CodeStatsSystem([[10, [102, 101]], [12, [122]], [22, [221]]]) changeCodelines(221, 3, 500) changeCodelines(102, 2, 1900) changeCodelines(101, 1, 2000) changeCodelines(101, 2, 200) statLanguage(10) statLanguage(22) changeCodelines(102, 3, 2000) changeCodelines(102, 2, -100) statLanguage(0)复制输出：null 500 1900 2000 200 [2, 1] [3] 2000 1800 [3, 1, 2]解释：第一、二次调用 statLanguage 查询时，各产品、代码仓的代码量如下：    产品 代码仓 代码量     22 221 3(java): 500   10 102 2(go): 1900   10 101 1(c++): 2000   10 101 2(go): 200     第一次统计，产品10 下代码仓中有 go（代码行2100 = 1900 + 200）和 c++（代码行2000）两种语言，优先按代码量从大到小返回 [2, 1] 第二次统计，产品22 下只有 java 一种语言，返回 [3]  第三次统计，产品id 为 0 表示查询所有产品：    产品 代码仓 代码量     22 221 3(java): 500   10 102 2(go): 1800   10 102 3(java): 2000   10 101 1(c++): 2000   10 101 2(go): 200     java 语言代码总量 2500 （500+2000）最大；go 和 c++ 的代码总量均为 2000 行，按语言id 升序 c++ 在前。 因此返回 [3, 1, 2]  样例2复制输入：CodeStatsSystem([[10, [102, 101]]]) statLanguage(0) changeCodelines(102, 2, 100) statLanguage(0) changeCodelines(102, 2, -100) statLanguage(0)复制输出：null [] 100 [2] 0 []解释：首次统计时，所有语言的初始代码量都为 0，因此返回结果为空列表。 第二次统计时，语言2(go) 代码量 100，返回该语言。 第三次统计时，语言2(go) 代码量变为 0，因此返回结果为空列表。

提示:
// 初始化及调用参考（以 C 为例，其他语言参考）： CodeStatsSystem *sys = CodeStatsSystemCreate(products, productsSize); int param_1 = CodeStatsSystemChangeCodelines(sys, repoId, languageId, codeline); int *param_2 = CodeStatsSystemStatLanguage(sys, productId, &returnSize); CodeStatsSystemFree(sys); 答题温馨

框架代码:
"进行下载。 2）输入输出由框架完成转换，答题要基于待实现函数/方法的定义完成。 3）编写的代码需要符合CleanCode的要求，特别注意扣分为 0 的场景，如：最大圈复杂度大于 20，嵌套深度大于等于 8 。 C重置代码 下载完整框架代码 xxxxxxxxxx40 1/*2 * Copyright (c) Huawei Technologies Co., Ltd. 2019. All rights reserved.3 * Description: 上机编程认证4 * Caution：本地调试时，只编译运行 main.c 文件，不要链接这个文件！因为本文件已经被 main.c 文件include了5 */6​7typedef struct {8    int productId;9    int *repoIds;10    size_t repoIdsSize;11} RroductRepos;12​13typedef struct {14​15} CodeStatsSystem;16​17// 注意：该函数为类构造函数，返回的对象指针将作为其他待实现函数的入参；框架代码在调用该函数后，会输出 null（而非指针）18// 注意：入参 products 指针在该函数被调用后，会被框架代码调用free进行内存释放19static CodeStatsSystem *CodeStatsSystemCreate(const RroductRepos *products, size_t productsSize)20{21    return NULL;22}23​24static int CodeStatsSystemChangeCodelines(CodeStatsSystem *sys, int repoId, int languageId, int codeline)25{26    return 0;27}28​29// 注意：返回的数组必须在函数内调用malloc进行内存分配，由框架代码调用free进行内存释放。30// 同时，所返回的数组长度必须保存在 *returnSize 中。31static int *CodeStatsSystemStatLanguage(CodeStatsSystem *sys, int productId, size_t *returnSize)32{33    *returnSize = 0;34    return NULL;35}36​37static void CodeStatsSystemFree(CodeStatsSystem *sys)38{39​40}


--- 新数据处理结果 ---

--- 新数据处理结果 ---
标题:
随机一题

题目描述:
【软件认证】文本编辑框 一个简易的文本编辑器，初始为空行，光标在行首，默认小写；请实现如下功能：  a-z 按下键盘对应的 26 个字母键，在光标位置

输入:
一个字符。 @ 表示大小写切换。 + 在光标位置换行，把光标右边的内容作为新行插入在当前行之后。 ~ 表示退格键，可删除光标左边字符；当光标在行首时，将当前行拼接到到上一行（如果存在）行尾。 - 表示删除键，可删除光标右边字符；当光标在行尾时，将下一行（如果存在）拼接到当前行行尾。 ^*<> 分别表示上下左右方向键：  左右移动，光标横向移动一个位置：  当光标在行首时，左移到上一行（如果存在）行尾； 当光标在行尾时，右移到下一行（如果存在）行首。   上下移动，光标纵向移动一行：  若在首行上移，或在末行下移，则移动无效； 相邻行：如果目标行内容长度小于光标的列位置，则光标移动到目标行行尾。注意：仅根据当前光标的列位置来移动，不记忆之前的位置。      请根据键盘输入信息 inputStr，

输出:
最终的文本内容。 解答要求 时间限制: C/C++ 1000ms, 其他语言：2000ms  内存限制: C/C++ 256MB, 其他语言：512MB 输入inputStr 仅包含小写字母a-z及功能字符+~-@^*<>，1 <= inputStr.length < 1024 输出字符串列表，每个元素表示一行内容（注意：空行 """" 不能忽略）。

样例:
1复制输入：""aaaa+bbbb~@cc<<<^--d@d""复制输出：[""aaDd"", ""bbbCC""]解释：初始为空行，光标在行首。 aaaa+：第一行输入aaaa，+ 换行，第二行内容为空，光标在第二行行首。 bbbb~：在第二行输入bbbb，然后 ~ 删除光标左侧的一个字符b，第二行内容变为bbb，光标在行尾。 @cc   ：@ 切换为大写输入，然后输入两个C，第二行内容变为bbbCC。 <<<^ ：光标左移 3 个位置，然后上移 1 行到第一行aaaa中间位置，如图所示：  --     ：删除光标右边 2 个a，第一行剩余aa，且光标在行尾。 d@d   ：大写状态输入一个D后，切换为小写再输入一个d，第一行内容变为aaDd。 最终内容为两行，用列表记录为 [""aaDd"", ""bbbCC""] 样例2复制输入：""za+b+cd^*e^^~*~>>~""复制输出：[""abced""]解释：za+b+cd：输入三行字符串，分别为：za，b，cd，光标在第三行行尾。 ^*e： 光标在第三行，光标从第三行行尾 ^ 上移时，第二行内容长度小于光标列位置，因此上移到第二行的行尾（即 b 后）； 然后 * 下移到（仅参考当前光标位置进行移动）第三行 c 后； 再输入字符 e 后，第三行为 ced，光标在 e 后。 ^^~：^^ 光标连续上移两行，到第一行的 za 中间位置； 然后 ~ 退格键删除左边字符；第一行变为 a，光标位置在行首。 *~：光标下移到第二行的行首；然后退格键将第二行拼接到第一行行尾，后续行平移；第一行变为 ab，第二行变为 ced。光标在第一行 ab 中间。 >>~：>> 光标连续右移两次到第二行行首，然后退格键 ~ 将第二行拼接到第一行行尾，最终内容为一行，即：abced。 样例3复制输入：""^*><+++^^a**b+^""复制输出：["""", ""a"", """", ""b"", """"]解释：^*>< 试图移动光标，但移动无效。 最终文本内容中，首行、最后一行、第三行为空字符串 """"

提示:
答题温馨

框架代码:
"进行下载。 2）输入输出由框架完成转换，答题要基于待实现函数/方法的定义完成。 3）编写的代码需要符合CleanCode的要求，特别注意扣分为 0 的场景，如：最大圈复杂度大于 20，嵌套深度大于等于 8 。 C重置代码 下载完整框架代码 xxxxxxxxxx29 1​2// 执行或提交代码时，仅包含待实现函数的必需代码，不要有多余代码（如：程序执行入口代码）3​4// 注意：返回的数组必须在函数内调用malloc进行内存分配，由框架代码调用free进行内存释放。5// 同时，所返回的数组长度必须保存在 *returnSize 中。6static char **StrEdit(const char *inputStr, size_t *returnSize)7{8    // 如果返回的数据为 [""aaDd"", ""bbbCC""]，返回的数据回填方式参考如下9    // *returnSize = 2;10    // char **res = (char**)malloc((*returnSize) * sizeof(char*));11    // if (res == NULL) {12    //     ... // 错误处理13    // }14    // const char *name = ""aaDd"";15    // size_t len = strlen(name) + 1;16    // res[0] = (char*)malloc(len);17    // if (res[0] == NULL) {18    //     ... // 错误处理19    // }20    // if (strcpy_s(res[0], len, name) != EOK) {21    //     ... // 错误处理22    // }23    // ...24    // return res;25​26    *returnSize = 0;27    return NULL;28}29​


--- 新数据处理结果 ---

--- 新数据处理结果 ---
标题:
随机一题

题目描述:
【软件认证】虚拟机部署 虚拟化是云计算的重要技术之一，使用虚拟化技术，可以在一台物理机上部署一个或多个虚拟机，以优化资源的使用。 现有一批物理机记录于数组 capacities中，capacities[i] 表示编号为 i 的物理机初始内存大小；同时给出一批虚拟机部署请求requests， 其元素依次表示待部署的虚拟机所需要的内存大小。 请按如下规则依次处理 requests中的每个虚拟机部署请求，并返回每个虚拟机部署所在的物理机编号（或者 -1）：  如果没有物理机的可用内存大于等于待部署的虚拟机所需内存，则该虚拟机部署失败，返回-1； 否则，按照以下方式选择一台物理机用于部署这个虚拟机，返回选中物理机的编号：  优先选择可用内存最大的物理机； 如果可用内存最大的物理机有多台，则在其中选择当前已部署虚拟机数量最少的物理机； 如果当前已部署虚拟机数量最少的物理机仍有多台，则在其中选择编号最小的物理机。

输入:
第1个参数为数组 capacities；0 < capacities.length <= 100000, 0 < capacities[i] <= 100000 第2个参数为数组 requests；0 < requests.length <= 100000, 0 < requests[i] <= 100000

输出:
一个数组，其元素依次为requests中每个请求的部署结果

样例:
1复制输入：[10, 32, 32, 64] [32, 16, 33]复制输出：[3, 1, -1]解释：第1个虚拟机需要的内存大小为32，在可用内存最大的物理机3上部署（部署后可用内存余下 32）。 第2个虚拟机需要的内存大小为16，此时物理机1、2、3的可用内存大小均为32，但是物理机3已经部署了一个虚拟机，因此优先在物理机1、2中选择；由于物理机1、2上部署的虚拟机数量都为0，因此选择编号更小的物理机1； 第3个虚拟机需要的内存大小为33，没有物理机的可用内存大于等于33，部署失败，返回-1。 样例2复制输入：[100000, 60000] [40000, 40000]复制输出：[0, 1]解释：部署第2个虚拟机时，两台物理机可用内存都为60000，但是物理机0已经部署了一个虚拟机，因此选择已部署虚拟机数量最少的物理机1。

提示:
答题温馨

框架代码:
"进行下载。 2）输入输出由框架完成转换，答题要基于待实现函数/方法的定义完成。 3）编写的代码需要符合CleanCode的要求，特别注意扣分为 0 的场景，如：最大圈复杂度大于 20，嵌套深度大于等于 8 。 C重置代码 下载完整框架代码 xxxxxxxxxx13 1/*2 * Copyright (c) Huawei Technologies Co., Ltd. 2019. All rights reserved.3 * Description: 上机编程认证4 * Caution：本地调试时，只编译运行 main.c 文件，不要链接这个文件！因为本文件已经被 main.c 文件include了5 */6​7// 注意：返回的数组必须在函数内调用malloc进行内存分配，由框架代码调用free进行内存释放。8// 同时，所返回的数组长度必须保存在 *returnSize 中。9static int *DispatchRequests(const int *capacities, size_t capacitiesSize, const int *requests, size_t requestsSize, size_t *returnSize)10{11    *returnSize = 0;12    return NULL;13}


--- 新数据处理结果 ---

--- 新数据处理结果 ---
标题:
随机一题

题目描述:
【软件认证】ARP miss缓存 某网络设备向目的IP发送报文时，需要在ARP表中根据已配置的表项（表项即为IP 和 MAC地址的映射关系），找到对应的MAC地址，补全报文的二层信息后进行转发；如果找不到，则需要将报文缓存起来，等到后续配置了对应的表项后，再立即进行补发。 请实现如下接口：   ArpSys(int arpCap, int cachedPktCap, int perIpCap) - 初始化  ARP表中表项的最大数量为 arpCap； 缓存能力：设备最多可缓存 cachedPktCap 个报文，且同一个IP最多缓存perIpCap 个报文。    update(int ip, string macAddr)  - 配置一条ARP表的表项：   如果已存在该 ip 的映射关系，则覆盖该 ip 对应的 macAddr；返回空列表 []。   如果不存在，  当表项未满时，直接添加一条表项； 当表项已满时，将最久未被命中（包括查询、添加和覆盖配置）的表项替换。  添加或替换表项后，将该 ip 缓存的报文升序返回（模拟补发），然后清空对应 ip 的缓存报文。     forward(int ip, int pktId)  - 在ARP表中查询此 ip 对应的 macAddr，进行模拟转发：  若找到对应的 macAddr，则返回该 macAddr 表示能成功转发； 否则，尝试将报文 pktId 进行缓存，返回空字符串 """" ：  若超出 cachedPktCap 或 perIpCap 中的任一个，则缓存失败； 否则，缓存成功。    注：报文 pktId 全局唯一。   解答要求 时间限制: C/C++ 1000ms, 其他语言：2000ms  内存限制: C/C++ 256MB, 其他语言：512MB

输入:
每行表示一个函数调用，初始化函数仅首行调用一次，累计函数调用不超过 1000 次。 1 <= perIpCap <= cachedPktCap <= 100，1 <= arpCap <= 100， 1 <= ip <= 2^31 - 1, 0 <= pktId <= 10000， macAddr.length == 17，MAC地址格式为：以十六进制[0-9A-F]表示，字节以-间隔，如：CC-DD-EE-FF-AA-09

输出:
按顺序输出每个函数的执行结果。注：无返回结果的函数，框架自动输出字符串"null"。

样例:
1复制输入：ArpSys(3, 3, 2) update(123, ""AB-AB-AB-AB-AB-AB"") forward(456, 23) forward(456, 0) forward(456, 8) update(456, ""BA-BA-BA-BA-BA-BA"") update(123, ""CD-EF-AB-AA-AB-AB"") forward(123, 5)复制输出：null [] """" """" """" [0, 23] [] ""CD-EF-AB-AA-AB-AB""解释：ArpSys(3, 3, 2) // 初始化ARP表的最大容量为 3，设备最多可缓存 3 个报文，每个IP最多缓存 2 个报文。 update(123, ""AB-AB-AB-AB-AB-AB"") // 添加表项，由于无缓存报文，返回 [] forward(456, 23) // 未找到 ip = 456 的表项，缓存报文 23 成功，返回空字符串 """" forward(456, 0) // 未找到 ip = 456 的表项，缓存报文 0 成功，返回空字符串 """" forward(456, 8) // 未找到 ip = 456 的表项，由于该IP已缓存了2个报文，新的报文缓存失败，返回空字符串 """" update(456, ""BA-BA-BA-BA-BA-BA"") // 添加表项成功，并将缓存的报文按 pktId 升序返回 update(123, ""CD-EF-AB-AA-AB-AB"") // 已存在 ip = 123 的表项，覆盖对应的MAC，该IP无缓存，返回 [] forward(123, 5) // ARP表存在该IP对应的MAC，直接返回 样例2复制输入：ArpSys(2, 4, 3) update(456, ""AB-AB-AB-AB-AB-AB"") update(111, ""CD-CD-CD-CD-CD-CD"") forward(123, 30) forward(789, 15) forward(456, 1) forward(123, 20) forward(789, 40) forward(123, 10) update(789, ""CC-DD-EE-FF-AA-01"") forward(123, 50) update(456, ""EF-EF-EF-EF-EF-08"") forward(789, 80) update(111, ""BC-BC-BC-BC-BC-03"") forward(456, 100)复制输出：null [] [] """" """" ""AB-AB-AB-AB-AB-AB"" """" """" """" [15, 40] """" [] ""CC-DD-EE-FF-AA-01"" [] """"解释：ArpSys(2, 4, 3) update(456, ""AB-AB-AB-AB-AB-AB"") update(111, ""CD-CD-CD-CD-CD-CD"") forward(123, 30) forward(789, 15) forward(456, 1) forward(123, 20) forward(789, 40) forward(123, 10) // 之前已缓存 4 个报文，由于设备最多可缓存 4 个报文，此报文被丢弃 update(789, ""CC-DD-EE-FF-AA-01"") // 由于ARP表已满，最久未被访问的 ip = 111 的表项被替换出去。注意：ip = 456，在操作 forward(456, 1) 访问过 forward(123, 50) // 报文缓存成功 update(456, ""EF-EF-EF-EF-EF-08"") forward(789, 80) update(111, ""BC-BC-BC-BC-BC-03"") // 替换掉最久未被访问的 ip = 456 的表项。注意：ip = 789，在上一个操作forward也做了访问 forward(456, 100) // ip = 456 的表项不存在，缓存报文成功

提示:
// 初始化及调用参考（以 C 为例，其他语言参考）： ArpSys *sys = ArpSysCreate(arpCap, cachedPktCap, perIpCap); int *param_1 = ArpSysUpdate(sys, ip, macAddr, &returnSize); char *param_2 = ArpSysForward(sys, ip, pktId); ArpSysFree(sys); 答题温馨

框架代码:
"进行下载。 2）输入输出由框架完成转换，答题要基于待实现函数/方法的定义完成。 3）编写的代码需要符合CleanCode的要求，特别注意扣分为 0 的场景，如：最大圈复杂度大于 20，嵌套深度大于等于 8 。 C重置代码 下载完整框架代码 xxxxxxxxxx33 1​2// 执行或提交代码时，仅包含待实现函数的必需代码，不要有多余代码（如：程序执行入口代码）3​4typedef struct {5​6} ArpSys;7​8// 注意：该函数为类构造函数，返回的对象指针将作为其他待实现函数的入参；框架代码在调用该函数后，会输出 null（而非指针）9static ArpSys *ArpSysCreate(int arpCap, int cachedPktCap, int perIpCap)10{11    return NULL;12}13​14// 注意：返回的数组必须在函数内调用malloc进行内存分配，由框架代码调用free进行内存释放。15// 同时，所返回的数组长度必须保存在 *returnSize 中。16// 注意：入参 macAddr 指针在该函数被调用后，会被框架代码调用free进行内存释放17static int *ArpSysUpdate(ArpSys *sys, int ip, const char *macAddr, size_t *returnSize)18{19    *returnSize = 0;20    return NULL;21}22​23// 注意：返回的字符串必须在函数内调用malloc进行内存分配，由框架代码调用free进行内存释放。24static char *ArpSysForward(ArpSys *sys, int ip, int pktId)25{26    return NULL;27}28​29static void ArpSysFree(ArpSys *sys)30{31​32}33​


--- 新数据处理结果 ---

--- 新数据处理结果 ---
标题:
随机一题

题目描述:
【软件认证】VLAN配置信息 二层转发设备的端口支持 vlan ， vlan-id 的配置仅支持两种命令，格式为：  port trunk allow-pass vlan <vlan-id> -- 配置允许通过的 vlan-id undo port trunk allow-pass vlan <vlan-id> -- 配置不允许通过的 vlan-id （命令中的undo 表示不允许）  其中 <vlan-id> 有三种：  单个 vlan-id：如 10； vlan-id 区间：用to连接两 id 来表示，格式为 id1 to id2（id1 < id2，左闭右闭），如 10 to 11； 任意多个以上两种组合，之间用单个空格分隔，如 10 20 to 22 12，表示 10, 12, 20, 21, 22。  所有 vlan-id 在初始状态下均为不允许通过状态。现用户针对某一端口

输入:
一组命令 cmds，用于配置该端口的 vlan-id。请按输入顺序依次处理，最后转化成一条等效最简的命令，转化要求如下：  <vlan-id>里的所有单个 vlan-id 值和 vlan-id 区间之间都没有重叠，且按 vlan-id 从小到大排列； 所有连续的 vlan-id 范围全部表示成 vlan-id 区间，如 8 和 9 需要表示成 8 to 9 。  注：用例保证最终允许通过的 vlan-id 至少一个。 输入1 <= cmds.length <= 100, 单条命令长度不超过 255，1 <= vlan-id <= 4095 输入保证每条命令格式合法（命令中的 vlan-id 为十进制整数），且单条配置命令里 vlan-id 无重复。

输出:
用例保证输出长度不超过255，格式同"配置允许通过的 vlan-id" 的命令

样例:
1复制输入：[""port trunk allow-pass vlan 10 20 to 30"", ""port trunk allow-pass vlan 15 to 25 9"", ""undo port trunk allow-pass vlan 10 to 20 23""]复制输出：""port trunk allow-pass vlan 9 21 to 22 24 to 30""解释：第一条命令后，允许通过的vlan-id为：10, [20,30] 第二条命令后，允许通过的vlan-id为：[9,10], [15,30] 第三条命令后，允许通过的vlan-id为：9, [21,22], [24,30] 样例2复制输入：[""undo port trunk allow-pass vlan 10 to 20"", ""port trunk allow-pass vlan 17 to 20 24 to 4094"", ""port trunk allow-pass vlan 21 to 24"", ""port trunk allow-pass vlan 1 to 15 4095 16""]复制输出：""port trunk allow-pass vlan 1 to 4095""解释：vlan-id 从1到4095都允许通过

提示:
答题温馨

框架代码:
"进行下载。 2）输入输出由框架完成转换，答题要基于待实现函数/方法的定义完成。 3）编写的代码需要符合CleanCode的要求，特别注意扣分为 0 的场景，如：最大圈复杂度大于 20，嵌套深度大于等于 8 。 C重置代码 下载完整框架代码 xxxxxxxxxx44 1/*2 * Copyright (c) Huawei Technologies Co., Ltd. 2019. All rights reserved.3 * Description: 上机编程认证4 * Caution：本地调试时，只编译运行 main.c 文件，不要链接这个文件！因为本文件已经被 main.c 文件include了5 */6​7// 注意：返回的字符串必须在函数内调用malloc进行内存分配，由框架代码调用free进行内存释放。8static char *MergeCmds(char **cmds, size_t cmdsSize)9{10    return NULL;11}12​13/*14 * 此函数用于：拆分字符串，如 delim = "" &/""，delim中的每个字符均作为分隔符进行字符串拆分15 * 输入：input表示待拆分的字符串，delim表示分隔符，bufSize表示result数组长度，result用于存放拆分后的字符串16 * 返回：拆分后的字符串数组的大小。若拆分后的字符串个数大于bufSize，返回0。17 * 例：函数调用前定义一个数组result[4][MAX_STR_LEN]，入参input = "" 123 2a&7!/bcd/"", delim =  "" &/"", bufSize = 4,18 * 调用后函数返回 4，result[0] = ""123"", result[1] = ""2a"", result[2] = ""7!"", result[3] = ""bcd""19 */20/*21#define MAX_STR_LEN 256  // 请根据题目的要求修改值的大小22static int SplitString(const char *input, const char *delim, int bufSize, char result[][MAX_STR_LEN])23{24    size_t len = strlen(input);25    char *str = (char*)malloc(len + 1);26    if (str == NULL) { return 0; }27    if (strncpy_s(str, len + 1, input, len) != EOK) { return 0; }28​29    int cnt = 0;30    char *buff = NULL;31    char *p = strtok_s(str, delim, &buff);32    while (p != NULL) {33        if (cnt >= bufSize || strcpy_s(result[cnt], MAX_STR_LEN, p) != EOK) {34            free(str);35            return 0;36        }37        p = strtok_s(NULL, delim, &buff);38        cnt++;39    }40​41    free(str);42    return cnt;43}44*/


--- 新数据处理结果 ---

--- 新数据处理结果 ---
标题:
随机一题

题目描述:
【软件认证】串口自适应接收（系统软件专业） UART作为异步串行通信协议的一种，工作原理是将传输数据的每个二进制位逐位传输。请实现一个简化版的UART接收侧数字信号解码功能。 传输数据的格式，以样例一为例，

输入:
的字节流与比特流对应关系如下图 ：    空闲位（可选）：当没有数据传输时持续

输出:
空闲位，全 1 或 没有。   开始位： 每开始一次数据传输，先发出一个 0 的信号，表示传输开始。占 1 bit。   数据位： 开始位后是数据，先低位，后高位。数据位宽可以是 5、6、7、8、9 位。   校验位（可选）： 若存在，则紧跟数据位后，占 1 bit，分为奇、偶校验；若不存在，则不占位，为无校验。  奇校验：如果数据位中 1 的数目是偶数，则校验位为 1 ，如果数目是奇数，校验位为 0。 偶校验：如果数据为中 1 的数目是偶数，则校验位为 0 ，如果数目是奇数，校验位为 1。    停止位： 它是一次数据传输的结束标志，占 1 bit，固定为 1。   现定义「串口配置」：为数据位宽与校验位的配置组合，其中：  数据位宽有 5 种可能配置： [5,6,7,8,9] 校验位有 3 种可能配置：[无校验，奇校验, 偶校验]  请根据输入字节流 data 自适应识别串口配置，并提取数据位，按bit紧排、每 8 位组成一个字节后输出有效的字节流数据内容，最后一个字节如果不足 8 位，则在高位补 0。如示例 1 图。 自适应识别机制：一个用例输入的数据流一定是完全相同的「串口配置」，如果找到多种串口配置，则选择数据位宽最小的「串口配置」；若位宽也相同，优先选择无校验。 注意：用例输入保证合法，为若干个完整的数据传输，格式为16进制字符串，函数入参 data 是​​已转换后的字节流。用例保证有解。 解答要求 时间限制: C/C++ 1000ms, 其他语言：2000ms  内存限制: C/C++ 256MB, 其他语言：512MB 输入一个16进制字符串 data （字符为[0-9A-F]，字母为大写)，每两个字符表示1个字节，2 <= data.length <= 5000，且data.length为 2 的整数倍 输出提取的有效的字节流数据

样例:
一为例，输入的字节流与比特流对应关系如下图 ：    空闲位（可选）：当没有数据传输时持续输出空闲位，全 1 或 没有。   开始位： 每开始一次数据传输，先发出一个 0 的信号，表示传输开始。占 1 bit。   数据位： 开始位后是数据，先低位，后高位。数据位宽可以是 5、6、7、8、9 位。   校验位（可选）： 若存在，则紧跟数据位后，占 1 bit，分为奇、偶校验；若不存在，则不占位，为无校验。  奇校验：如果数据位中 1 的数目是偶数，则校验位为 1 ，如果数目是奇数，校验位为 0。 偶校验：如果数据为中 1 的数目是偶数，则校验位为 0 ，如果数目是奇数，校验位为 1。    停止位： 它是一次数据传输的结束标志，占 1 bit，固定为 1。   现定义「串口配置」：为数据位宽与校验位的配置组合，其中：  数据位宽有 5 种可能配置： [5,6,7,8,9] 校验位有 3 种可能配置：[无校验，奇校验, 偶校验]  请根据输入字节流 data 自适应识别串口配置，并提取数据位，按bit紧排、每 8 位组成一个字节后输出有效的字节流数据内容，最后一个字节如果不足 8 位，则在高位补 0。如示例 1 图。 自适应识别机制：一个用例输入的数据流一定是完全相同的「串口配置」，如果找到多种串口配置，则选择数据位宽最小的「串口配置」；若位宽也相同，优先选择无校验。 注意：用例输入保证合法，为若干个完整的数据传输，格式为16进制字符串，函数入参 data 是​​已转换后的字节流。用例保证有解。 解答要求 时间限制: C/C++ 1000ms, 其他语言：2000ms  内存限制: C/C++ 256MB, 其他语言：512MB 输入一个16进制字符串 data （字符为[0-9A-F]，字母为大写)，每两个字符表示1个字节，2 <= data.length <= 5000，且data.length为 2 的整数倍 输出提取的有效的字节流数据 样例1复制输入：""675EF3""复制输出：""A601""解释：输入字节转换为bit流如上图，低位先传输，首字节为 0x67，bit流传输以 11100110 开始。 数据位宽 5 bit、奇校验的「串口配置」是数据位宽最少的「串口配置」。 注意：一个用例输入的数据流一定是完全相同的「串口配置」，因此若第 1 段数据采用数据位宽 5 bit、奇校验的配置，第 2 段及其后的数据也必须都采用此配置进行解码。 如上图，提取的数据位按bit紧排为 0110010110，每8位组成1个字节，由于最后一个字节不足8位，补 0 后，如下图  最终输出数据：A601 样例2复制输入：""7F017F027F037FF4FFFF""复制输出：""010203F4""解释：输入字节转换为bit流为 11111110100000001111111001000000111111101100000011111110001011111111111111111111 识别出2种合法配置： 数据位--8bit, 校验位--无； 数据位--9bit, 校验位--无； 按数据位最小要求，选配置：数据位 8 bit，无校验位 按配置提取出数据：010203F4 样例3复制输入：""A85FF1237FD82FF9313FEA37FCC85FF14B7ED82FF929BFE1""复制输出：""B4109C181DA4249CD400""解释：识别出4种合法配置： 数据位--5bit, 校验位--偶校验； 数据位--6bit, 校验位--无； 数据位--7bit, 校验位--无； 数据位--8bit, 校验位--无； 按数据位最小要求，选配置：数据位 5 bit，偶校验 按配置提取出数据：B4109C181DA4249CD400

提示:
答题温馨

框架代码:
"进行下载。 2）输入输出由框架完成转换，答题要基于待实现函数/方法的定义完成。 3）编写的代码需要符合CleanCode的要求，特别注意扣分为 0 的场景，如：最大圈复杂度大于 20，嵌套深度大于等于 8 。 C重置代码 下载完整框架代码 xxxxxxxxxx17 1​2// 答题框内的代码仅为待实现代码，执行或提交代码时，仅包含待实现部分，不要包含其它代码。3// CodeCheck/Cmetrics工具也仅扫描待实现部分。4// 若需要完整框架用于本地调试，请点击答题框上面的"下载完整框架代码"进行下载。5​6// 注意：用例输入的16进制字符串 data 已转成 uint8_t 字节流格式7// 假设用例输入为 ""675EF3""，已转换为字节流 uint8_t *data = [0x67,0x5E,0xF3]，且 dataSize 为 3 。8//9// 注意：返回的数组必须在函数内调用malloc进行内存分配，由框架代码调用free进行内存释放。10// 返回字节流 uint8_t *，框架自动打印成16进制字符串。11// 例如返回 [0xA6,0x01]，*returnSize = 2，框架自动打印为 ""A601""。12static uint8_t *UartRxDecode(const uint8_t *data, size_t dataSize, size_t *returnSize)13{14    *returnSize = 0;15    return NULL;16}17​


--- 新数据处理结果 ---

--- 新数据处理结果 ---
标题:
随机一题

题目描述:
【软件认证】收包驱动（错包过滤+乱序整理）（系统软件专业） 网络设备通常需要使用硬件控制器（如网卡）来对报文进行收发，网卡驱动会接收字节流并解析出有效的报文内容。每个报文解析前都要先依照魔术字进行定帧，定帧后按照报文结构进行解析；之后再继续查找下一个魔术字，解析报文；重复以上过程，直至字节流末尾。 魔术字值固定为十六进制 ABAC9527，报文格式为 序号（1字节） + 长度（1字节） + 净荷（字节数等于长度，可以为空），见下图所示：  现给定接收到的字节流 data ，请按以下规则解析出每条正常报文，然后进行去重和重排，最后返回拼接的报文净荷。规则如下：  首先，定帧：以魔术字 ABAC9527 来定帧；若遇到异常报文，则需要重新定帧。  定帧后，解析一条报文时，若在这条报文内（序号 + 长度 + 净荷）包含魔术字 ABAC9527 ，则报文异常，用该魔术字进行重新定帧； 当解析的报文超出 data 范围，则报文异常，从上一次定帧之后继续查找下一个魔术字进行定帧。   成功定帧后，解析出正常报文。  去重：序号相同的为重复报文，以首次收到的为准。 重排：重排后序号升序连续（起始序号为最小序号），当中间出现丢包时，后续报文全部丢弃。 解答要求 时间限制: C/C++ 1000ms, 其他语言：2000ms  内存限制: C/C++ 256MB, 其他语言：512MB

输入:
一个16进制的字符串（字符为[0-9A-F]，字母为大写)，如""ABAC95""，每两个字符表示1个字节  2 <= 字符串长度（偶数） <= 20000 所有字段均为网络字节序(即大端序)，大端序的高位字节在低地址，小端序的高位字节在高地址，如：数字 65538，其4字节表示的大端序内容为 00010002，小端序内容为 02000100

输出:
返回拼接的报文净荷，16进制的字符串（字符为[0-9A-F]，字母为大写)

样例:
1复制输入：""01ABAC9527040132ABAC9527ABAC95270202A1A2ABAC95270601CDABAC95270300ABAC95270201EFABAC""复制输出：""A1A232""解释：参考题目中的图：  重新定帧：ABAC9527ABAC95270202A1A2，前一次定帧后，解析报文时出现异常，需要重新定帧。 所有报文解析完成后，报文序号依次为 [4, 2, 6, 3, 2]。去重和重排后为 [2, 3, 4]  最小序号为 2，是起始序号； 报文2 为重复报文，丢弃后收到的（内容可能不同）； 报文6 与前面报文4 不连续，出现丢包，报文6 被丢弃。   返回的是报文 2、3、4 的净荷拼接，其中报文3 的净荷为空。  样例2复制输入：""ABAC9527ABAC95270201D1ABAC952701ABAC95270001B402ABAC95270104ABAC9527010400ABAC95270302CDEFABAC95270202CFDE""复制输出：""B400ABAC95D1""解释：将输入分成多段，定帧和解析过程参考如下： ABAC9527：无效 ABAC95270201D1：报文2 ABAC952701：无效 ABAC95270001B4：报文0 02：无效 ABAC95270104：报文长度为4，报文 0104ABAC9527 含魔术字，是异常报文，需重新定帧 ABAC9527010400ABAC95：重新定帧后，是正常的报文1，报文净荷为 00ABAC95。注：报文中含有魔术字的一部分 ABAC95，但不能和此报文外的相邻字节 27 组合为一个魔术字。 270302CDEF：无效 ABAC95270202CFDE：报文2 重复，以之前收到的报文为准 样例3复制输入：""ABAC9527030001ABAC952705FFABAC95270A01EEABAC952704""复制输出：""""解释： 报文3 的净荷为空，是正常报文；报文5 的净荷长度为 255，超出 data 范围，为异常报文；报文10 是正常报文，净荷为 EE；报文4 解析时超出 data 范围 报文3 之后出现丢包，因此报文10 丢弃

提示:
答题温馨

框架代码:
"进行下载。 2）输入输出由框架完成转换，答题要基于待实现函数/方法的定义完成。 3）编写的代码需要符合CleanCode的要求，特别注意扣分为 0 的场景，如：最大圈复杂度大于 20，嵌套深度大于等于 8 。 C重置代码 下载完整框架代码 xxxxxxxxxx17 1​2// 答题框内的代码仅为待实现代码，执行或提交代码时，仅包含待实现部分，不要包含其它代码。3// CodeCheck/Cmetrics工具也仅扫描待实现部分。4// 若需要完整框架用于本地调试，请点击答题框上面的"下载完整框架代码"进行下载。5​6// 注意：用例输入的16进制字符串 data 已转成 uint8_t 字节流格式7// 假设用例输入为 ""01ABAC""，已转换为字节流 uint8_t *data = [0x01,0xAB,0xAC]，且 dataSize 为 3 。8//9// 注意：返回的数组必须在函数内调用malloc进行内存分配，由框架代码调用free进行内存释放。10// 返回字节流 uint8_t *，框架自动打印成16进制字符串。11// 例如返回 [0x01,0xAB,0xAC]，*returnSize = 3，框架自动打印为 ""01ABAC""。12static uint8_t *StreamRecv(const uint8_t *data, size_t dataSize, size_t *returnSize)13{14    *returnSize = 0;15    return NULL;16}17​


--- 新数据处理结果 ---

--- 新数据处理结果 ---
标题:
随机一题

题目描述:
【软件认证】分片报文的重组（系统软件专业） 由于通信设备之间的通信包大小有限制，发送端会将原始报文分片发送，接收端收到所有分片报文后重组成原始报文。现给定一批报文 rcvPkts ，请实现接收端重组功能，并返回重组后的原始报文。 分片报文和重组后报文（和原始报文一致）格式如下图所示：  一个原始报文的唯一标识是编号PacketNo，载荷长度为PayloadLen，发送端把它分成SliceNum个分片报文；分片报文的分片号 SliceIdx 合法范围是[0, SliceNum - 1]，载荷长度为SlicePayloadLen，分片报文的DstDevId/SrcDevId/PayloadLen来自原始报文。 接收端收到分片报文后，将PacketNo相同的分片报文，按照分片号SliceIdx从小到大重组成原始报文。 假设接收端收到若干分片报文，请重组成原始报文（可能有多个），并把成功重组的原始报文按照PacketNo从小到大输出。 如下图所示：  由于通信链路不是绝对可靠的，若某报文存在以下异常场景，则放弃这一原始报文的重组： • 分片报文存在丢包导致无法收齐 • 分片报文编号SliceIdx重复出现 • 分片报文载荷长度（SlicePayloadLen）的累加和，与原始报文载荷长度（PayloadLen）不一致 • 分片报文编号SliceIdx不在合法范围内 注意： • 用例

输入:
是字符串，例如 ""AABB""，框架函数会将其转换为16进制字节流形式作为入参，如 0xAA, 0xBB 这样的字节流；函数的

输出:
。 如下图所示：  由于通信链路不是绝对可靠的，若某报文存在以下异常场景，则放弃这一原始报文的重组： • 分片报文存在丢包导致无法收齐 • 分片报文编号SliceIdx重复出现 • 分片报文载荷长度（SlicePayloadLen）的累加和，与原始报文载荷长度（PayloadLen）不一致 • 分片报文编号SliceIdx不在合法范围内 注意： • 用例输入是字符串，例如 ""AABB""，框架函数会将其转换为16进制字节流形式作为入参，如 0xAA, 0xBB 这样的字节流；函数的输出也为字节流，框架会将其自动转换为字符串打印输出。 • 报文从左到右是从低地址到高地址，报文的存储和发送全部使用小端字节序； • 用例保证相同PacketNo的报文DstDevId/SrcDevId/PayloadLen/SliceNum一定相同。 解答要求 时间限制: C/C++ 1000ms, 其他语言：2000ms  内存限制: C/C++ 256MB, 其他语言：512MB 输入• 0 <= PacketNo <= 65535，且不一定连续 • 收到的报文都是分片格式的报文； • 1<= rcvPkts.length <= 2000，即分片报文个数不超过2000，16 <= rcvPkts[i].length（即每个分片报文长度） <= 128； • 用例输入的16进制字符串（字符为[0-9A-F]，字母为大写)，每两个字符表示1个字节，字符串长度一定是8的整数倍，框架会转换为16进制整数码流； 输出重组后的原始报文

样例:
1复制输入：[""010200000C000000030001000400000055667788"", ""010200000C000000030000000400000022334455"", ""010200000C00000003000200040000008899AABB""]复制输出：[""010200000C00000022334455556677888899AABB""]解释：以分片报文 010200000C000000030001000400000055667788 为例，01代表DstDevid，02代表SrcDevid，0000代表packetNo，0C000000代表PayloadLen=0x0000000C，0300代表SliceNum=0x0003，0100代表SliceIdx=0x0001，04000000代表SlicePayloadLen=0x00000004，55667788是四个字节的载荷。 输入的报文分片索引依次是1,0,2，因此最终的报文按照分片索引0,1,2排序重组后输出。 包头：010200000C000000 重组后的Payload：22334455556677888899AABB 样例2复制输入：[""010200000C000000030001000400000055667788"", ""010200000C00000003000200040000008899AABB""]复制输出：[]解释：分片索引0丢失，整个包丢弃，不输出

提示:
答题温馨

框架代码:
"进行下载。 2）输入输出由框架完成转换，答题要基于待实现函数/方法的定义完成。 3）编写的代码需要符合CleanCode的要求，特别注意扣分为 0 的场景，如：最大圈复杂度大于 20，嵌套深度大于等于 8 。 C重置代码 下载完整框架代码 xxxxxxxxxx28 1​2// 答题框内的代码仅为待实现代码，执行或提交代码时，仅包含待实现部分，不要包含其它代码。3// CodeCheck/Cmetrics工具也仅扫描待实现部分。4// 若需要完整框架用于本地调试，请点击答题框上面的"下载完整框架代码"进行下载。5​6// 注意：7// 1）用例输入输出涉及的16进制字符串均用 uint8_t 字节流格式来代替8// 2）输出涉及的内存都必须在待实现函数内调用malloc进行内存分配，由框架代码调用free进行内存释放9// *returnColSizes 数组的长度也为 *returnSize。10//11// 输入举例：输入为 [""0102"", ""F3F4F5""]，则12// rcvPktsSize 为 2，rcvPktsColSize[0] = 2，rcvPktsColSize[1] = 313// rcvPkts[0][0] = 0x01, rcvPkts[0][1] = 0x0214// rcvPkts[1][0] = 0xF3, rcvPkts[1][1] = 0xF4, rcvPkts[1][2] = 0xF515//16// 输出举例：输出为 [""A1A2A3"", ""0405""]，则 *returnSize = 217// *returnColSizes数组需要函数内分配，并填充 (*returnColSizes)[0] = 3，(*returnColSizes)[1] = 218// 返回的 res 需要函数内分配，且 res[i] 也需要分配，并填充如下19// res[0][0] = 0xA1, res[0][1] = 0xA2, res[0][2] = 0xA320// res[1][0] = 0x04, res[1][1] = 0x0521static uint8_t **ReassemblePacket(uint8_t **rcvPkts, size_t rcvPktsSize, const size_t *rcvPktsColSize,22                                  size_t *returnSize, size_t **returnColSizes)23{24    *returnSize = 0;25    *returnColSizes = NULL;26    return NULL;27}28​


--- 新数据处理结果 ---

--- 新数据处理结果 ---
标题:
随机一题

题目描述:
【软件认证】基于日志的系统故障预测 某通讯设备系统定义了一系列系统事件，当事件发生时会将该事件ID记录到日志中，该日志的数据全集称为原始事件序列。根据经验，当某些特征事件出现时，往往预示着系统存在需要解决的潜在问题。 现给定一组原始事件序列 events（元素可以重复），以及一个特征序列 traits （元素不重复） 请在 events 中从左往右按匹配规则找到一个匹配特征序列的最短连续子序列；如果存在多个最短的，则返回最早匹配到的连续子序列。 匹配规则：对于 events 中的某个连续子序列，当从中去除 n 个（n >= 0）元素后、且不破坏余下元素的相对位置所形成的新序列和特征序列 traits 相同时，则该连续子序列是匹配特征序列的。 注：

输入:
保证至少存在一个匹配的连续子序列。 输入第一个参数是数组 events，代表原始事件序列，1 < events.length <= 1000 第二个参数是数组 traits，代表特征序列，1 <= traits.length <= 20 0 <= events[i], traits[i] <= 1000

输出:
一个连续子序列

样例:
1复制输入：[4, 8, 4, 3, 6, 6, 8] [4, 6, 8]复制输出：[4, 3, 6, 6, 8]解释： 如 event 中的一个连续子序列 [4, 3, 6, 6, 8] ，去除其中元素 3 和 任一个 6 后、且余下元素保持相对顺序不变，所形成的新序列 [4, 6, 8] 和特征序列相同，因此所选择的连续子序列 [4, 3, 6, 6, 8] 是匹配特征序列的。 样例2复制输入：[2, 30, 4, 4, 6, 2, 2, 3, 4, 6, 6, 2, 4, 4, 6] [2, 4, 6]复制输出：[2, 3, 4, 6]解释：匹配到的最短连续子序列长度为 4，有两个，分别是 [2, 3, 4, 6] 和 [2, 4, 4, 6]； 其中最早出现的为  [2, 3, 4, 6]。

提示:
答题温馨

框架代码:
"进行下载。 2）输入输出由框架完成转换，答题要基于待实现函数/方法的定义完成。 3）编写的代码需要符合CleanCode的要求，特别注意扣分为 0 的场景，如：最大圈复杂度大于 20，嵌套深度大于等于 8 。 C重置代码 下载完整框架代码 xxxxxxxxxx14 1/*2 * Copyright (c) Huawei Technologies Co., Ltd. 2019. All rights reserved.3 * Description: 上机编程认证4 * Caution：本地调试时，只编译运行 main.c 文件，不要链接这个文件！因为本文件已经被 main.c 文件include了5 */6​7// 注意：返回的数组必须在函数内调用malloc进行内存分配，由框架代码调用free进行内存释放。8// 同时，所返回的数组长度必须保存在 *returnSize 中。9static int *MatchLogTrait(const int *events, size_t eventsSize,10                          const int *traits, size_t traitsSize, size_t *returnSize)11{12    *returnSize = 0;13    return NULL;14}


--- 新数据处理结果 ---

--- 新数据处理结果 ---
标题:
随机一题

题目描述:
【软件认证】挑选礼物 某部门进行团建，提供两种礼物供员工挑选：雨伞、无线鼠标，分别用数字 1 和 2 表示。 每个员工都有自己喜欢的礼物，记录于 favorites 中；礼物的总数与员工人数相同，记录于 presents 中。 所有礼物放在一个栈里，员工只能从栈顶获取礼物。 员工排成一个队列依次获取礼物，  如果队列最前面的员工所喜欢的礼物刚好是栈顶的礼物，那么该员工就会拿走它，并离开队列； 否则，该员工会走到队列尾部，等待下一次挑选。 这个过程会一直持续到队列里所有员工都不喜欢栈顶的礼物为止。  注意：favorites 中下标为 0 表示队列最开始位置，presents 中下标为 0 表示栈顶。 请最后返回无法获取到礼物的员工数量。

输入:
第一个参数表示 favorites，1 <= favorites.length <= 100，favorites[i] 值仅为 1 或 2； 第二个参数表示 presents，1 <= presents.length <= 100，且 presents.length == favorites.length，presents[i] 值仅为 1 或 2；

输出:
返回无法获取到礼物的员工数量

样例:
1复制输入：[1, 2, 2, 1, 2] [2, 1, 1, 2, 1]复制输出：1解释： 队首的员工放弃最顶上的礼物，并回到队列的末尾，队列变为 favorites = [2, 2, 1, 2, 1]。 队首的员工拿走最顶上的礼物，并离开队列，队列变为 favorites = [2, 1, 2, 1]，礼物为 presents = [1, 1, 2, 1]。 队首的员工放弃最顶上的礼物，并回到队列的末尾，队列变为 favorites = [1, 2, 1, 2]。 队首的员工拿走最顶上的礼物，并离开队列，队列变为 favorites = [2, 1, 2]，礼物为 presents = [1, 2, 1]。 队首的员工放弃最顶上的礼物，并回到队列的末尾，队列变为 favorites = [1, 2, 2]。 队首的员工拿走最顶上的礼物，并离开队列，队列变为 favorites = [2, 2]，礼物为 presents = [2, 1]。 队首的员工拿走最顶上的礼物，并离开队列，队列变为 favorites = [2]，礼物为 presents = [1]。 最后剩余的 1 名员工不喜欢最顶上的礼物，因此返回 1。

提示:
答题温馨

框架代码:
"进行下载。 2）输入输出由框架完成转换，答题要基于待实现函数/方法的定义完成。 3）编写的代码需要符合CleanCode的要求，特别注意扣分为 0 的场景，如：最大圈复杂度大于 20，嵌套深度大于等于 8 。 C重置代码 下载完整框架代码 xxxxxxxxxx10 1/*2 * Copyright (c) Huawei Technologies Co., Ltd. 2019. All rights reserved.3 * Description: 上机编程认证4 * Caution：本地调试时，只编译运行gift.c文件，不要链接这个文件！因为本文件已经被gift.c文件include了5 */6​7static int GetUnselectedNum(const int *favorites, size_t favoritesSize, const int *presents, size_t presentsSize)8{9    return 0;10}

