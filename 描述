【软件认证】文本编辑框

一个简易的文本编辑器，初始为空行，光标在行首，默认小写；请实现如下功能：

a-z 按下键盘对应的 26 个字母键，在光标位置输入一个字符。
@ 表示大小写切换。
+ 在光标位置换行，把光标右边的内容作为新行插入在当前行之后。
~ 表示退格键，可删除光标左边字符；当光标在行首时，将当前行拼接到到上一行（如果存在）行尾。
- 表示删除键，可删除光标右边字符；当光标在行尾时，将下一行（如果存在）拼接到当前行行尾。
^*<> 分别表示上下左右方向键：
左右移动，光标横向移动一个位置：
当光标在行首时，左移到上一行（如果存在）行尾；
当光标在行尾时，右移到下一行（如果存在）行首。
上下移动，光标纵向移动一行：
若在首行上移，或在末行下移，则移动无效；
相邻行：如果目标行内容长度小于光标的列位置，则光标移动到目标行行尾。注意：仅根据当前光标的列位置来移动，不记忆之前的位置。
请根据键盘输入信息 inputStr，输出最终的文本内容。


输入
inputStr 仅包含小写字母a-z及功能字符+~-@^*<>，1 <= inputStr.length < 1024

输出
字符串列表，每个元素表示一行内容（注意：空行 "" 不能忽略）。

样例1
复制输入：
"aaaa+bbbb~@cc<<<^--d@d"
复制输出：
["aaDd", "bbbCC"]
解释：
初始为空行，光标在行首。
aaaa+：第一行输入aaaa，+ 换行，第二行内容为空，光标在第二行行首。
bbbb~：在第二行输入bbbb，然后 ~ 删除光标左侧的一个字符b，第二行内容变为bbb，光标在行尾。
@cc ：@ 切换为大写输入，然后输入两个C，第二行内容变为bbbCC。
<<<^ ：光标左移 3 个位置，然后上移 1 行到第一行aaaa中间位置，如图所示：
image.png
-- ：删除光标右边 2 个a，第一行剩余aa，且光标在行尾。
d@d ：大写状态输入一个D后，切换为小写再输入一个d，第一行内容变为aaDd。

最终内容为两行，用列表记录为 ["aaDd", "bbbCC"]

样例2
复制输入：
"za+b+cd^*e^^~*~>>~"
复制输出：
["abced"]
解释：
za+b+cd：输入三行字符串，分别为：za，b，cd，光标在第三行行尾。
^*e： 光标在第三行，光标从第三行行尾 ^ 上移时，第二行内容长度小于光标列位置，因此上移到第二行的行尾（即 b 后）； 然后 * 下移到（仅参考当前光标位置进行移动）第三行 c 后； 再输入字符 e 后，第三行为 ced，光标在 e 后。
^^~：^^ 光标连续上移两行，到第一行的 za 中间位置； 然后 ~ 退格键删除左边字符；第一行变为 a，光标位置在行首。
*~：光标下移到第二行的行首；然后退格键将第二行拼接到第一行行尾，后续行平移；第一行变为 ab，第二行变为 ced。光标在第一行 ab 中间。
>>~：>> 光标连续右移两次到第二行行首，然后退格键 ~ 将第二行拼接到第一行行尾，最终内容为一行，即：abced。

样例3
复制输入：
"^*><+++^^a**b+^"
复制输出：
["", "a", "", "b", ""]
解释：
^*>< 试图移动光标，但移动无效。
最终文本内容中，首行、最后一行、第三行为空字符串 ""
static char **StrEdit(const char *inputStr, size_t *returnSize)
{
    *returnSize = 0;
    return NULL;
}


_________________________________________________________
软件认证】虚拟机部署

虚拟化是云计算的重要技术之一，使用虚拟化技术，可以在一台物理机上部署一个或多个虚拟机，以优化资源的使用。

现有一批物理机记录于数组 capacities中，capacities[i] 表示编号为 i 的物理机初始内存大小；同时给出一批虚拟机部署请求requests， 其元素依次表示待部署的虚拟机所需要的内存大小。

请按如下规则依次处理 requests中的每个虚拟机部署请求，并返回每个虚拟机部署所在的物理机编号（或者 -1）：

如果没有物理机的可用内存大于等于待部署的虚拟机所需内存，则该虚拟机部署失败，返回-1；
否则，按照以下方式选择一台物理机用于部署这个虚拟机，返回选中物理机的编号：
优先选择可用内存最大的物理机；
如果可用内存最大的物理机有多台，则在其中选择当前已部署虚拟机数量最少的物理机；
如果当前已部署虚拟机数量最少的物理机仍有多台，则在其中选择编号最小的物理机。
输入
第1个参数为数组 capacities；0 < capacities.length <= 100000, 0 < capacities[i] <= 100000
第2个参数为数组 requests；0 < requests.length <= 100000, 0 < requests[i] <= 100000

输出
一个数组，其元素依次为requests中每个请求的部署结果

样例1
复制输入：
[10, 32, 32, 64]
[32, 16, 33]
复制输出：
[3, 1, -1]
解释：
第1个虚拟机需要的内存大小为32，在可用内存最大的物理机3上部署（部署后可用内存余下 32）。
第2个虚拟机需要的内存大小为16，此时物理机1、2、3的可用内存大小均为32，但是物理机3已经部署了一个虚拟机，因此优先在物理机1、2中选择；由于物理机1、2上部署的虚拟机数量都为0，因此选择编号更小的物理机1；
第3个虚拟机需要的内存大小为33，没有物理机的可用内存大于等于33，部署失败，返回-1。

样例2
复制输入：
[100000, 60000]
[40000, 40000]
复制输出：
[0, 1]
解释：
部署第2个虚拟机时，两台物理机可用内存都为60000，但是物理机0已经部署了一个虚拟机，因此选择已部署虚拟机数量最少的物理机1。


static char **StrEdit(const char *inputStr, size_t *returnSize)
{

    *returnSize = 0;
    return NULL;
}
